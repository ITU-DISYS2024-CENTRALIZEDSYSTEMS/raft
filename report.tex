% report.tex

\documentclass[a4paper,11pt]{article}
\usepackage{hyperref}
\usepackage{enumitem}
\usepackage{varwidth}
\usepackage{tasks}
% Import packages
\usepackage[a4paper]{geometry}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{enumerate}
\usepackage{geometry}
 \geometry{
 a4paper,
 total={170mm,257mm},
 left=20mm,
 top=20mm,
 }

\usepackage{graphicx}

\usepackage{listings}


% Change enumerate environments you use letters
\renewcommand{\theenumi}{\alph{enumi}}

% Set title, author name and date
\title{Raft}
\author{Johannes JÃ¸rgensen (jgjo),\\ Kevin Skovgaard Gravesen (kegr),\\ Joakim Andreasen (joaan)} 
\date{\today}

\begin{document} 

\maketitle

\subsection*{Introduction}

\subsection*{Go features}
The raft implementation is written using go routines and some channels.
Some examples of the go routines being used could be the appending and commiting of information to the log, election handling and heartbeats.
The reason for the use of channels is to move the decisions and actions take by the goroutines to the main routine.
By combining these go features as much of the Raft implementation is multithreaded as possible.

Go's defer keyword is also used but, besides the routine and channel usage, the rest of the go features is built in go quality of life features.
Which is Go's spin on features from other languages, such as slices.

\subsection*{Node communication}

\subsection*{Implementation quality}

\subsubsection*{Election safety}
A constant running "electionTicker" go routine is being sleept with a random amount of time.
This is to ensure that no two nodes are asking for an election at the same time.
The "mutex" structure is also used for atomic locks which ensures that each node's internal decisions can be trusted.
And that a node for example is not both accepting another node to be elected and voting on it self at the same time.

\subsubsection*{Leader Append-Only}
Multiple checks are in place to ensure that only the leader could append to the log.
That can, among other places, be seen in the "sendAppendEntries" function that send new entries to the other nodes.
This function have a check in it that prevents to node from sending anything if it is not the leader.
With this even a wrongly use of the method won't cause an issue in this case, even tho it should be rectified.

The majority requirement of adding to the log is also implemented, 
which Raft requires to ensure that the leader is not deciding on decisions without the other nodes following along.

\subsubsection*{Log Matching}

\subsubsection*{Leader completeness}

\subsubsection*{State Machine Safety}

\subsection*{Source}
\href{https://github.com/jmsadair/raft}{https://github.com/jmsadair/raft}

\end{document}